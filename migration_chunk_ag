  p_error_message TEXT DEFAULT NULL
) RETURNS VOID AS $$
BEGIN
  UPDATE automation_jobs 
  SET 
    status = p_status,
    completed_at = NOW(),
    result = p_result,
    error_message = p_error_message,
    updated_at = NOW()
  WHERE id = p_job_id;
END;
$$ LANGUAGE plpgsql SECURITY DEFINER;

-- =============================================
-- TRIGGER FUNCTIONS
-- =============================================

-- Trigger function for new signups
CREATE OR REPLACE FUNCTION process_signup_trigger()
RETURNS TRIGGER AS $$
BEGIN
  -- Create signup event
  PERFORM create_automation_event(
    'signup',
    NEW.id,
    jsonb_build_object(
      'email', NEW.email,
      'name', NEW.name,
      'signup_date', NEW.created_at
    ),
    'system',
    NULL
  );
  
  RETURN NEW;
END;
$$ LANGUAGE plpgsql SECURITY DEFINER;

-- Create trigger for signup events
DROP TRIGGER IF EXISTS automation_signup_trigger ON subscribers;
CREATE TRIGGER automation_signup_trigger
  AFTER INSERT ON subscribers
  FOR EACH ROW EXECUTE FUNCTION process_signup_trigger();

-- Trigger function for email opens
CREATE OR REPLACE FUNCTION process_email_open_trigger()
RETURNS TRIGGER AS $$
BEGIN
  -- Create email open event
  PERFORM create_automation_event(
    'email_open',
    NEW.subscriber_id,
    jsonb_build_object(
      'campaign_id', NEW.campaign_id,
      'email_id', NEW.email_id,
      'opened_at', NEW.opened_at
    ),
    'email_tracking',
    NULL
  );
  
  RETURN NEW;
END;
$$ LANGUAGE plpgsql SECURITY DEFINER;

-- Create trigger for email open events
DROP TRIGGER IF EXISTS automation_email_open_trigger ON email_opens;
CREATE TRIGGER automation_email_open_trigger
  AFTER INSERT ON email_opens
  FOR EACH ROW EXECUTE FUNCTION process_email_open_trigger();

-- Trigger function for email clicks
CREATE OR REPLACE FUNCTION process_email_click_trigger()
RETURNS TRIGGER AS $$
BEGIN
  -- Create email click event
  PERFORM create_automation_event(
    'email_click',
    NEW.subscriber_id,
    jsonb_build_object(
      'campaign_id', NEW.campaign_id,
      'email_id', NEW.email_id,
      'url', NEW.url,
      'clicked_at', NEW.clicked_at
    ),
    'email_tracking',
    NULL
  );
  
  RETURN NEW;
END;
$$ LANGUAGE plpgsql SECURITY DEFINER;

-- Create trigger for email click events
DROP TRIGGER IF EXISTS automation_email_click_trigger ON email_clicks;
CREATE TRIGGER automation_email_click_trigger
  AFTER INSERT ON email_clicks
  FOR EACH ROW EXECUTE FUNCTION process_email_click_trigger();

-- =============================================
-- INITIAL DATA SETUP
-- =============================================

-- Insert default custom fields
INSERT INTO automation_custom_fields (name, field_type, description, options) VALUES
  ('subscription_type', 'select', 'Type of subscription', '["free", "pro", "enterprise"]'),
  ('signup_source', 'select', 'How the user signed up', '["website", "app", "referral", "social"]'),
  ('language', 'select', 'Preferred language', '["en", "es", "fr", "de", "it"]'),
  ('company_size', 'select', 'Company size', '["1-10", "11-50", "51-200", "201-1000", "1000+"]'),
  ('industry', 'text', 'Industry or sector', '[]'),
  ('last_login', 'date', 'Last login date', '[]'),
  ('total_purchases', 'number', 'Total number of purchases', '[]'),
  ('lifetime_value', 'number', 'Customer lifetime value', '[]'),
  ('birthday', 'date', 'Birthday for anniversary campaigns', '[]'),
  ('phone', 'text', 'Phone number', '[]')
ON CONFLICT (name) DO NOTHING;

-- Create initial partitions for current and next month
DO $$
DECLARE
  current_month TEXT := to_char(CURRENT_DATE, 'YYYY_MM');
  next_month TEXT := to_char(CURRENT_DATE + INTERVAL '1 month', 'YYYY_MM');
BEGIN
  -- Events partitions
  EXECUTE format('CREATE TABLE IF NOT EXISTS automation_events_%s PARTITION OF automation_events FOR VALUES FROM (%L) TO (%L)',
    current_month, 
    date_trunc('month', CURRENT_DATE),
    date_trunc('month', CURRENT_DATE + INTERVAL '1 month')
  );
  
  EXECUTE format('CREATE TABLE IF NOT EXISTS automation_events_%s PARTITION OF automation_events FOR VALUES FROM (%L) TO (%L)',
    next_month,
    date_trunc('month', CURRENT_DATE + INTERVAL '1 month'),
    date_trunc('month', CURRENT_DATE + INTERVAL '2 months')
  );
  
  -- Webhook logs partitions
  EXECUTE format('CREATE TABLE IF NOT EXISTS automation_webhook_logs_%s PARTITION OF automation_webhook_logs FOR VALUES FROM (%L) TO (%L)',
    current_month,
    date_trunc('month', CURRENT_DATE),
    date_trunc('month', CURRENT_DATE + INTERVAL '1 month')
  );
  
  EXECUTE format('CREATE TABLE IF NOT EXISTS automation_webhook_logs_%s PARTITION OF automation_webhook_logs FOR VALUES FROM (%L) TO (%L)',
    next_month,
    date_trunc('month', CURRENT_DATE + INTERVAL '1 month'),
    date_trunc('month', CURRENT_DATE + INTERVAL '2 months')
  );
END $$;

-- =============================================
-- COMMENTS FOR DOCUMENTATION
-- =============================================

COMMENT ON TABLE email_automations IS 'Main automation workflows with trigger configuration and workflow definitions';
COMMENT ON TABLE email_automation_enrollments IS 'Tracks subscriber enrollments in automations with progress tracking';
COMMENT ON TABLE automation_step_executions IS 'Logs individual step executions with performance metrics';
COMMENT ON TABLE automation_jobs IS 'Background job queue for scalable automation processing';
COMMENT ON TABLE automation_events IS 'Event tracking for trigger detection (partitioned by date)';
COMMENT ON TABLE automation_custom_fields IS 'Custom field definitions for advanced segmentation';
COMMENT ON TABLE automation_subscriber_fields IS 'Subscriber custom field values';
COMMENT ON TABLE automation_segments IS 'Dynamic segmentation with caching';
COMMENT ON TABLE automation_segment_members IS 'Cached segment membership for performance';
COMMENT ON TABLE automation_email_templates IS 'Automation-specific email templates with A/B testing support';
COMMENT ON TABLE automation_webhooks IS 'Webhook endpoints for external integrations';
COMMENT ON TABLE automation_webhook_logs IS 'Webhook call logs (partitioned by date)';

-- Success message
DO $$
BEGIN
  RAISE NOTICE 'Email Automation System migration completed successfully!';
  RAISE NOTICE 'Created: % tables, % types, % functions, % triggers', 
    (SELECT COUNT(*) FROM information_schema.tables WHERE table_name LIKE 'automation_%' OR table_name LIKE 'email_automation%'),
    (SELECT COUNT(*) FROM pg_type WHERE typname LIKE 'automation_%' OR typname LIKE 'enrollment_%' OR typname LIKE 'job_%'),
    (SELECT COUNT(*) FROM pg_proc WHERE proname LIKE '%automation%'),
    (SELECT COUNT(*) FROM pg_trigger WHERE tgname LIKE 'automation_%');
END $$;

-- RPC function to increment email sent count for automation enrollments
CREATE OR REPLACE FUNCTION increment_enrollment_emails_sent(enrollment_id UUID)
RETURNS void AS $$
BEGIN
  UPDATE email_automation_enrollments 
  SET 
    emails_sent = COALESCE(emails_sent, 0) + 1,
    updated_at = NOW()
  WHERE id = enrollment_id;
END;
$$ LANGUAGE plpgsql SECURITY DEFINER;

-- Grant execute permission to authenticated users and service role
GRANT EXECUTE ON FUNCTION increment_enrollment_emails_sent(UUID) TO authenticated;
GRANT EXECUTE ON FUNCTION increment_enrollment_emails_sent(UUID) TO service_role;



-- ============================================================================
-- Migration: 20250704000000_enhance_automation_purchase_triggers.sql
-- ============================================================================

-- Enhanced Purchase Triggers and Audience Management for Email Automations
-- Created: 2025-01-03
-- Description: Add purchase event triggers and audience management actions to automation system

-- =============================================
-- SUBSCRIPTION CHANGE TRIGGERS
-- =============================================

-- Function to create subscription change events
CREATE OR REPLACE FUNCTION process_subscription_change_trigger()
RETURNS TRIGGER AS $$
BEGIN
  -- Only trigger if subscription actually changed
  IF OLD.subscription IS DISTINCT FROM NEW.subscription OR 
     OLD.subscription_expiration IS DISTINCT FROM NEW.subscription_expiration THEN
    
    -- Find subscriber for this profile
    DECLARE
      subscriber_id_var UUID;
    BEGIN
      SELECT id INTO subscriber_id_var 
      FROM subscribers 
      WHERE user_id = NEW.id 
      LIMIT 1;
      
      IF subscriber_id_var IS NOT NULL THEN
        -- Create subscription change event
        PERFORM create_automation_event(
          'subscription_change',
          subscriber_id_var,
          jsonb_build_object(
            'old_subscription', OLD.subscription,
            'new_subscription', NEW.subscription,
            'old_expiration', OLD.subscription_expiration,
            'new_expiration', NEW.subscription_expiration,
            'customer_id', NEW.customer_id,
            'change_date', NOW()
          ),
          'profile_update'
        );
      END IF;
    END;
  END IF;
  
  RETURN NEW;
END;
$$ LANGUAGE plpgsql SECURITY DEFINER;

-- Create trigger for subscription changes
DROP TRIGGER IF EXISTS automation_subscription_change_trigger ON profiles;
CREATE TRIGGER automation_subscription_change_trigger
  AFTER UPDATE ON profiles
  FOR EACH ROW EXECUTE FUNCTION process_subscription_change_trigger();

-- =============================================
-- AUDIENCE MANAGEMENT ACTIONS
-- =============================================

-- Enhanced automation step types to include audience management
DO $$ 
BEGIN
  -- Add new step types if they don't exist
  IF NOT EXISTS (
    SELECT 1 FROM pg_enum 
    WHERE enumlabel = 'audience_add' 
    AND enumtypid = 'automation_step_type'::regtype
  ) THEN
    ALTER TYPE automation_step_type ADD VALUE 'audience_add';
  END IF;
  
  IF NOT EXISTS (
    SELECT 1 FROM pg_enum 
    WHERE enumlabel = 'audience_remove' 
    AND enumtypid = 'automation_step_type'::regtype
  ) THEN
    ALTER TYPE automation_step_type ADD VALUE 'audience_remove';
  END IF;
  
  IF NOT EXISTS (
    SELECT 1 FROM pg_enum 
    WHERE enumlabel = 'tag_add' 
    AND enumtypid = 'automation_step_type'::regtype
  ) THEN
    ALTER TYPE automation_step_type ADD VALUE 'tag_add';
  END IF;
  
  IF NOT EXISTS (
    SELECT 1 FROM pg_enum 
    WHERE enumlabel = 'tag_remove' 
    AND enumtypid = 'automation_step_type'::regtype
  ) THEN
    ALTER TYPE automation_step_type ADD VALUE 'tag_remove';
  END IF;
END $$;

-- Enhanced automation trigger types to include purchase events
DO $$ 
BEGIN
  -- Add new trigger types if they don't exist
  IF NOT EXISTS (
    SELECT 1 FROM pg_enum 
    WHERE enumlabel = 'purchase_refunded' 
    AND enumtypid = 'automation_trigger_type'::regtype
  ) THEN
    ALTER TYPE automation_trigger_type ADD VALUE 'purchase_refunded';
  END IF;
  
  IF NOT EXISTS (
    SELECT 1 FROM pg_enum 
    WHERE enumlabel = 'subscription_change' 
    AND enumtypid = 'automation_trigger_type'::regtype
  ) THEN
    ALTER TYPE automation_trigger_type ADD VALUE 'subscription_change';
  END IF;
  
  IF NOT EXISTS (
    SELECT 1 FROM pg_enum 
    WHERE enumlabel = 'subscription_cancelled' 
    AND enumtypid = 'automation_trigger_type'::regtype
  ) THEN
    ALTER TYPE automation_trigger_type ADD VALUE 'subscription_cancelled';
  END IF;
  
  IF NOT EXISTS (
    SELECT 1 FROM pg_enum 
    WHERE enumlabel = 'segment_entry' 
    AND enumtypid = 'automation_trigger_type'::regtype
  ) THEN
    ALTER TYPE automation_trigger_type ADD VALUE 'segment_entry';
  END IF;
  
  IF NOT EXISTS (
    SELECT 1 FROM pg_enum 
    WHERE enumlabel = 'segment_exit' 
    AND enumtypid = 'automation_trigger_type'::regtype
  ) THEN
    ALTER TYPE automation_trigger_type ADD VALUE 'segment_exit';
  END IF;
END $$;

-- Function to add subscriber to audience
CREATE OR REPLACE FUNCTION add_subscriber_to_audience(
  p_subscriber_id UUID,
  p_audience_id UUID
) RETURNS BOOLEAN AS $$
BEGIN
  -- Check if audience exists and is static
  IF NOT EXISTS (
    SELECT 1 FROM email_audiences 
    WHERE id = p_audience_id 
    AND (filters->>'audience_type' = 'static' OR filters IS NULL)
  ) THEN
    RAISE EXCEPTION 'Audience not found or not static: %', p_audience_id;
  END IF;
  
  -- Add subscriber to audience (ignore if already exists)
  INSERT INTO email_audience_subscribers (audience_id, subscriber_id, added_at)
  VALUES (p_audience_id, p_subscriber_id, NOW())
  ON CONFLICT (audience_id, subscriber_id) DO NOTHING;
  
  -- Update audience subscriber count
  UPDATE email_audiences 
  SET subscriber_count = (
    SELECT COUNT(*) 
    FROM email_audience_subscribers 
    WHERE audience_id = p_audience_id
  ),
  updated_at = NOW()
  WHERE id = p_audience_id;
  
  RETURN TRUE;
EXCEPTION
  WHEN OTHERS THEN
    RETURN FALSE;
END;
$$ LANGUAGE plpgsql SECURITY DEFINER;

-- Function to remove subscriber from audience
CREATE OR REPLACE FUNCTION remove_subscriber_from_audience(
  p_subscriber_id UUID,
  p_audience_id UUID
) RETURNS BOOLEAN AS $$
BEGIN
  -- Remove subscriber from audience
  DELETE FROM email_audience_subscribers 
  WHERE audience_id = p_audience_id 
  AND subscriber_id = p_subscriber_id;
  
  -- Update audience subscriber count
  UPDATE email_audiences 
  SET subscriber_count = (
    SELECT COUNT(*) 
    FROM email_audience_subscribers 
    WHERE audience_id = p_audience_id
  ),
  updated_at = NOW()
  WHERE id = p_audience_id;
  
  RETURN TRUE;
EXCEPTION
  WHEN OTHERS THEN
    RETURN FALSE;
END;
$$ LANGUAGE plpgsql SECURITY DEFINER;

-- Function to create audience entry/exit events
CREATE OR REPLACE FUNCTION process_audience_membership_trigger()
RETURNS TRIGGER AS $$
BEGIN
  IF TG_OP = 'INSERT' THEN
    -- Create segment entry event
    PERFORM create_automation_event(
      'segment_entry',
      NEW.subscriber_id,
      jsonb_build_object(
        'audience_id', NEW.audience_id,
        'added_at', NEW.added_at
      ),
      'audience_management'
    );
    RETURN NEW;
  ELSIF TG_OP = 'DELETE' THEN
    -- Create segment exit event
    PERFORM create_automation_event(
      'segment_exit',
      OLD.subscriber_id,
      jsonb_build_object(
        'audience_id', OLD.audience_id,
        'removed_at', NOW()
      ),
      'audience_management'
    );
    RETURN OLD;
  END IF;
  
  RETURN NULL;
END;
$$ LANGUAGE plpgsql SECURITY DEFINER;

-- Create triggers for audience membership changes
DROP TRIGGER IF EXISTS automation_audience_membership_trigger ON email_audience_subscribers;
CREATE TRIGGER automation_audience_membership_trigger
  AFTER INSERT OR DELETE ON email_audience_subscribers
  FOR EACH ROW EXECUTE FUNCTION process_audience_membership_trigger();

-- =============================================
-- ENHANCED AUTOMATION PROCESSING
-- =============================================

-- Update the automation job processing to handle new step types
CREATE OR REPLACE FUNCTION execute_automation_step(
  p_enrollment_id UUID,
  p_step_config JSONB
) RETURNS JSONB AS $$
DECLARE
  step_type TEXT;
  step_result JSONB := '{"success": false}';
  subscriber_id_var UUID;
  audience_id_var UUID;
BEGIN
  -- Get subscriber ID for this enrollment
  SELECT subscriber_id INTO subscriber_id_var
  FROM email_automation_enrollments
  WHERE id = p_enrollment_id;
  
  step_type := p_step_config->>'type';
  
  CASE step_type
    WHEN 'audience_add' THEN
      audience_id_var := (p_step_config->>'audience_id')::UUID;
      IF add_subscriber_to_audience(subscriber_id_var, audience_id_var) THEN
        step_result := jsonb_build_object(
          'success', true,
          'action', 'audience_add',
          'audience_id', audience_id_var,
          'subscriber_id', subscriber_id_var
        );
      END IF;
      
    WHEN 'audience_remove' THEN
      audience_id_var := (p_step_config->>'audience_id')::UUID;
      IF remove_subscriber_from_audience(subscriber_id_var, audience_id_var) THEN
        step_result := jsonb_build_object(
          'success', true,
          'action', 'audience_remove',
          'audience_id', audience_id_var,
          'subscriber_id', subscriber_id_var
        );
      END IF;
      
    WHEN 'tag_add' THEN
      -- Add tag to subscriber
      UPDATE subscribers 
      SET tags = CASE 
        WHEN tags IS NULL THEN ARRAY[p_step_config->>'tag_name']
        WHEN NOT (tags @> ARRAY[p_step_config->>'tag_name']) THEN array_append(tags, p_step_config->>'tag_name')
        ELSE tags
      END,
      updated_at = NOW()
      WHERE id = subscriber_id_var;
      
      step_result := jsonb_build_object(
        'success', true,
        'action', 'tag_add',
        'tag_name', p_step_config->>'tag_name'
      );
      
    WHEN 'tag_remove' THEN
      -- Remove tag from subscriber
      UPDATE subscribers 
      SET tags = array_remove(tags, p_step_config->>'tag_name'),
          updated_at = NOW()
      WHERE id = subscriber_id_var;
      
      step_result := jsonb_build_object(
        'success', true,
        'action', 'tag_remove',
        'tag_name', p_step_config->>'tag_name'
      );
      
    ELSE
      step_result := jsonb_build_object(
        'success', false,
        'error', 'Unknown step type: ' || step_type
      );
  END CASE;
  
  RETURN step_result;
END;
$$ LANGUAGE plpgsql SECURITY DEFINER;

-- =============================================
-- PURCHASE-SPECIFIC AUTOMATION CONDITIONS
-- =============================================

-- Function to check purchase-related conditions using Stripe data
CREATE OR REPLACE FUNCTION evaluate_purchase_conditions(
  p_subscriber_id UUID,
  p_conditions JSONB
) RETURNS BOOLEAN AS $$
DECLARE
  condition_met BOOLEAN := true;
  condition JSONB;
  field_name TEXT;
  operator TEXT;
  expected_value TEXT;
  amount_threshold DECIMAL;
  purchase_count INTEGER;
  customer_id_var TEXT;
BEGIN
  -- Get customer ID for this subscriber
  SELECT p.customer_id INTO customer_id_var
  FROM subscribers s
  JOIN profiles p ON p.id = s.user_id
  WHERE s.id = p_subscriber_id;
  
  IF customer_id_var IS NULL THEN
    RETURN FALSE;
  END IF;
  
  -- Loop through each condition
  FOR condition IN SELECT * FROM jsonb_array_elements(p_conditions->'rules')
  LOOP
    field_name := condition->>'field';
    operator := condition->>'operator';
    expected_value := condition->>'value';
    
    CASE field_name
      WHEN 'purchase_amount' THEN
        -- Get total purchase amount from Stripe payment intents
        SELECT COALESCE(SUM((pi.amount::DECIMAL / 100)), 0) INTO amount_threshold
        FROM stripe_tables.stripe_payment_intents pi
        WHERE pi.customer = customer_id_var
        AND (pi.attrs->>'status') = 'succeeded';
        
        CASE operator
          WHEN 'greater_than' THEN
            condition_met := amount_threshold > expected_value::DECIMAL;
          WHEN 'less_than' THEN
            condition_met := amount_threshold < expected_value::DECIMAL;
          WHEN 'equals' THEN
            condition_met := amount_threshold = expected_value::DECIMAL;
          ELSE
            condition_met := FALSE;
        END CASE;
        
      WHEN 'purchase_count' THEN
        -- Get total purchase count from Stripe payment intents
        SELECT COUNT(*) INTO purchase_count
        FROM stripe_tables.stripe_payment_intents pi
        WHERE pi.customer = customer_id_var
        AND (pi.attrs->>'status') = 'succeeded';
        
        CASE operator
          WHEN 'greater_than' THEN
            condition_met := purchase_count > expected_value::INTEGER;
          WHEN 'less_than' THEN
            condition_met := purchase_count < expected_value::INTEGER;
          WHEN 'equals' THEN
            condition_met := purchase_count = expected_value::INTEGER;
          ELSE
            condition_met := FALSE;
        END CASE;
        
      WHEN 'subscription_status' THEN
        -- Check current subscription status from profiles
        SELECT EXISTS(
          SELECT 1 FROM profiles p
          WHERE p.customer_id = customer_id_var
          AND p.subscription = expected_value
        ) INTO condition_met;
        
      ELSE
        -- Unknown field, condition not met
        condition_met := FALSE;
    END CASE;
    
    -- If any condition fails, exit early
    IF NOT condition_met THEN
      EXIT;
    END IF;
  END LOOP;
  
  RETURN condition_met;
END;
$$ LANGUAGE plpgsql SECURITY DEFINER;

-- =============================================
-- SAMPLE AUTOMATION TEMPLATES
-- =============================================

-- Insert sample purchase-based automation templates
INSERT INTO automation_custom_fields (name, field_type, description, options) VALUES
  ('purchase_amount', 'number', 'Total purchase amount', '[]'),
  ('purchase_count', 'number', 'Total number of purchases', '[]'),
  ('last_purchase_date', 'date', 'Date of last purchase', '[]'),
  ('subscription_status', 'text', 'Current subscription status', '[]'),
  ('customer_lifetime_value', 'number', 'Total customer value', '[]')
ON CONFLICT (name) DO NOTHING;

-- Add indexes for performance on profiles table
CREATE INDEX IF NOT EXISTS idx_profiles_subscription_change 
ON profiles(subscription, subscription_expiration);

CREATE INDEX IF NOT EXISTS idx_profiles_customer_id 
ON profiles(customer_id) WHERE customer_id IS NOT NULL;

-- Add helpful comments
COMMENT ON FUNCTION process_subscription_change_trigger() IS 'Creates automation events when subscription status changes';
COMMENT ON FUNCTION add_subscriber_to_audience(UUID, UUID) IS 'Adds a subscriber to a static audience and updates counts';
COMMENT ON FUNCTION remove_subscriber_from_audience(UUID, UUID) IS 'Removes a subscriber from an audience and updates counts';
COMMENT ON FUNCTION execute_automation_step(UUID, JSONB) IS 'Executes automation steps including audience management actions';
COMMENT ON FUNCTION evaluate_purchase_conditions(UUID, JSONB) IS 'Evaluates purchase-related conditions for automation triggers using Stripe data'; 


-- ============================================================================
-- Migration: 20250705220813_fix_automation_events_schema.sql
-- ============================================================================

-- Fix automation_events table schema
-- Add event_source column if it doesn't exist
ALTER TABLE automation_events ADD COLUMN IF NOT EXISTS event_source VARCHAR(100) DEFAULT 'system';

-- Update any existing events without event_source
UPDATE automation_events 
SET event_source = 'system' 
WHERE event_source IS NULL;



-- ============================================================================
-- Migration: 20250705221227_cleanup_automation_trigger_types.sql
-- ============================================================================

-- Clean up automation trigger types
-- The current system uses automation_trigger enum with basic types
-- Add subscription_change trigger type and remove unwanted functions

-- First, remove any unwanted trigger functions and triggers if they exist
DROP TRIGGER IF EXISTS automation_email_open_trigger ON email_opens;
DROP FUNCTION IF EXISTS process_email_open_trigger();

DROP TRIGGER IF EXISTS automation_email_click_trigger ON email_clicks;
DROP FUNCTION IF EXISTS process_email_click_trigger();

-- Add subscription_change to the existing automation_trigger enum
ALTER TYPE automation_trigger ADD VALUE IF NOT EXISTS 'subscription_change';

-- Update the automation_trigger enum comment
COMMENT ON TYPE automation_trigger IS 'Available automation trigger types: signup, purchase, abandonment, anniversary, behavior, custom, subscription_change';

-- Ensure any test automations with invalid trigger types are cleaned up
DELETE FROM email_automations 
WHERE trigger_type::text IN ('email_open', 'email_click', 'segment_entry');



-- ============================================================================
-- Migration: 20250705221744_add_automation_id_to_email_sends.sql
-- ============================================================================

-- Add automation_id to email_sends table for tracking automation emails
ALTER TABLE email_sends 
ADD COLUMN IF NOT EXISTS automation_id UUID REFERENCES email_automations(id) ON DELETE SET NULL;

-- Add message_id column if it doesn't exist (for SES message tracking)
ALTER TABLE email_sends 
ADD COLUMN IF NOT EXISTS message_id VARCHAR(255);

-- Add index for automation email tracking
CREATE INDEX IF NOT EXISTS idx_email_sends_automation_id ON email_sends(automation_id) WHERE automation_id IS NOT NULL;

-- Add index for message_id tracking
CREATE INDEX IF NOT EXISTS idx_email_sends_message_id ON email_sends(message_id) WHERE message_id IS NOT NULL;



-- ============================================================================
-- Migration: 20250705223000_add_usage_count_to_email_templates.sql
-- ============================================================================

-- Add usage_count field to email_templates table
ALTER TABLE email_templates ADD COLUMN IF NOT EXISTS usage_count INTEGER DEFAULT 0;

-- Create an index on usage_count for better performance when sorting by usage
CREATE INDEX IF NOT EXISTS idx_email_templates_usage_count ON email_templates(usage_count); 


-- ============================================================================
-- Migration: 20251105023042_fix_admin_rls_policies.sql
-- ============================================================================

-- Combined RLS policies migration
-- This migration combines multiple RLS policy migrations:
-- - Tutorial tables RLS policies
-- - Email campaign tables RLS policies
-- - Email tracking tables RLS policies
-- - Email campaign audiences fix and storage policies

-- =============================================
-- Tutorial Tables RLS Policies
-- =============================================
-- Enable RLS on tutorial_videos
ALTER TABLE tutorial_videos ENABLE ROW LEVEL SECURITY;

-- Allow all authenticated users to read tutorial videos
CREATE POLICY "Allow authenticated users to read tutorial videos" ON tutorial_videos
  FOR SELECT 
  USING (auth.role() = 'authenticated');

-- Allow admins to insert tutorial videos
CREATE POLICY "Allow admins to insert tutorial videos" ON tutorial_videos
  FOR INSERT 
  WITH CHECK (is_admin(auth.uid()));

-- Allow admins to update tutorial videos
CREATE POLICY "Allow admins to update tutorial videos" ON tutorial_videos
  FOR UPDATE 
  USING (is_admin(auth.uid()));

-- Allow admins to delete tutorial videos
CREATE POLICY "Allow admins to delete tutorial videos" ON tutorial_videos
  FOR DELETE 
  USING (is_admin(auth.uid()));

-- Enable RLS on tutorial_playlists
ALTER TABLE tutorial_playlists ENABLE ROW LEVEL SECURITY;

-- Allow all authenticated users to read tutorial playlists
CREATE POLICY "Allow authenticated users to read tutorial playlists" ON tutorial_playlists
  FOR SELECT 
  USING (auth.role() = 'authenticated');

-- Allow admins to insert tutorial playlists
CREATE POLICY "Allow admins to insert tutorial playlists" ON tutorial_playlists
  FOR INSERT 
  WITH CHECK (is_admin(auth.uid()));

-- Allow admins to update tutorial playlists
CREATE POLICY "Allow admins to update tutorial playlists" ON tutorial_playlists
  FOR UPDATE 
  USING (is_admin(auth.uid()));

-- Allow admins to delete tutorial playlists
CREATE POLICY "Allow admins to delete tutorial playlists" ON tutorial_playlists
  FOR DELETE 
  USING (is_admin(auth.uid()));

-- Enable RLS on playlist_videos (junction table)
ALTER TABLE playlist_videos ENABLE ROW LEVEL SECURITY;

-- Allow all authenticated users to read playlist_videos
CREATE POLICY "Allow authenticated users to read playlist_videos" ON playlist_videos
  FOR SELECT 
  USING (auth.role() = 'authenticated');

-- Allow admins to insert playlist_videos
CREATE POLICY "Allow admins to insert playlist_videos" ON playlist_videos
  FOR INSERT 
  WITH CHECK (is_admin(auth.uid()));

-- Allow admins to update playlist_videos
CREATE POLICY "Allow admins to update playlist_videos" ON playlist_videos
  FOR UPDATE 
  USING (is_admin(auth.uid()));

-- Allow admins to delete playlist_videos
CREATE POLICY "Allow admins to delete playlist_videos" ON playlist_videos
  FOR DELETE 
  USING (is_admin(auth.uid()));

-- Enable RLS on user_tutorial_paths
ALTER TABLE user_tutorial_paths ENABLE ROW LEVEL SECURITY;

-- Allow users to read their own tutorial paths
CREATE POLICY "Allow users to read their own tutorial paths" ON user_tutorial_paths
  FOR SELECT 
  USING (auth.uid() = user_id);

-- Allow users to insert their own tutorial paths
CREATE POLICY "Allow users to insert their own tutorial paths" ON user_tutorial_paths
  FOR INSERT 
  WITH CHECK (auth.uid() = user_id);

-- Allow users to update their own tutorial paths
CREATE POLICY "Allow users to update their own tutorial paths" ON user_tutorial_paths
  FOR UPDATE 
  USING (auth.uid() = user_id);

-- Allow admins to read all tutorial paths
CREATE POLICY "Allow admins to read all tutorial paths" ON user_tutorial_paths
  FOR SELECT 
  USING (is_admin(auth.uid()));

-- =============================================
-- Email Campaign Tables RLS Policies
-- =============================================
-- Ensure RLS is enabled on all email campaign tables
ALTER TABLE email_campaigns ENABLE ROW LEVEL SECURITY;
ALTER TABLE email_audiences ENABLE ROW LEVEL SECURITY;
ALTER TABLE email_audience_subscribers ENABLE ROW LEVEL SECURITY;
ALTER TABLE email_campaign_audiences ENABLE ROW LEVEL SECURITY;
ALTER TABLE email_sends ENABLE ROW LEVEL SECURITY;
ALTER TABLE email_opens ENABLE ROW LEVEL SECURITY;
ALTER TABLE email_clicks ENABLE ROW LEVEL SECURITY;
ALTER TABLE email_templates ENABLE ROW LEVEL SECURITY;
ALTER TABLE email_automations ENABLE ROW LEVEL SECURITY;

-- Enable RLS on email_ab_tests if it exists
DO $$
BEGIN
  IF EXISTS (SELECT 1 FROM information_schema.tables WHERE table_schema = 'public' AND table_name = 'email_ab_tests') THEN
    ALTER TABLE email_ab_tests ENABLE ROW LEVEL SECURITY;
  END IF;
END $$;

-- Email campaigns policies (admins can manage all)
DROP POLICY IF EXISTS "Admins can manage campaigns" ON email_campaigns;
CREATE POLICY "Admins can manage campaigns" ON email_campaigns
  FOR ALL 
  USING (is_admin(auth.uid()));

-- Email audiences policies (admins can manage all)
DROP POLICY IF EXISTS "Admins can view all audiences" ON email_audiences;
DROP POLICY IF EXISTS "Admins can insert audiences" ON email_audiences;
DROP POLICY IF EXISTS "Admins can update audiences" ON email_audiences;
DROP POLICY IF EXISTS "Admins can delete audiences" ON email_audiences;
DROP POLICY IF EXISTS "Admins can manage audiences" ON email_audiences;

CREATE POLICY "Admins can manage audiences" ON email_audiences
  FOR ALL 
  USING (is_admin(auth.uid()));

-- Email audience subscribers policies (admins can manage all)
DROP POLICY IF EXISTS "Admins can manage audience subscribers" ON email_audience_subscribers;
CREATE POLICY "Admins can manage audience subscribers" ON email_audience_subscribers
  FOR ALL 
  USING (is_admin(auth.uid()));

-- Email campaign audiences policies (admins can manage all)
-- Note: This will be fixed/ensured in the later section
DROP POLICY IF EXISTS "Admins can manage campaign audiences" ON email_campaign_audiences;
CREATE POLICY "Admins can manage campaign audiences" ON email_campaign_audiences
  FOR ALL 
  USING (is_admin(auth.uid()));

-- Email sends policies (admins can manage all, needed for tracking)
DROP POLICY IF EXISTS "Admins can manage email sends" ON email_sends;
CREATE POLICY "Admins can manage email sends" ON email_sends
  FOR ALL 
  USING (is_admin(auth.uid()));

-- Email templates policies (admins can manage all)
DROP POLICY IF EXISTS "Admins can manage templates" ON email_templates;
CREATE POLICY "Admins can manage templates" ON email_templates
  FOR ALL 
  USING (is_admin(auth.uid()));

-- Subscribers table policies (ensure admins can manage all)
DROP POLICY IF EXISTS "Admins can manage all subscribers" ON subscribers;
DROP POLICY IF EXISTS "Admin can manage subscribers" ON subscribers;
CREATE POLICY "Admins can manage all subscribers" ON subscribers
  FOR ALL 
  USING (is_admin(auth.uid()));

-- Email automations policies (admins can manage all)
DROP POLICY IF EXISTS "Admins can manage automations" ON email_automations;
CREATE POLICY "Admins can manage automations" ON email_automations
  FOR ALL 
  USING (is_admin(auth.uid()));

-- A/B tests policies (admins can manage all)
-- Only create policies if the table exists
DO $$
BEGIN
  IF EXISTS (SELECT 1 FROM information_schema.tables WHERE table_schema = 'public' AND table_name = 'email_ab_tests') THEN
    EXECUTE 'DROP POLICY IF EXISTS "Admins can manage ab tests" ON email_ab_tests';
    EXECUTE 'CREATE POLICY "Admins can manage ab tests" ON email_ab_tests
      FOR ALL 
      USING (is_admin(auth.uid()))';
  END IF;
END $$;

-- =============================================
-- Email Tracking Tables RLS Policies
-- =============================================
-- Note: Tracking pixels use the service role key to bypass RLS entirely
-- This allows them to insert tracking records and update campaign statistics
-- without authentication. The RLS policies below protect against direct access.

-- Allow anonymous inserts for email tracking (fallback - tracking routes use service role key)
-- This is a safety net in case we need anonymous inserts, but the service role key is preferred
DROP POLICY IF EXISTS "Allow anonymous inserts for email opens" ON email_opens;
CREATE POLICY "Allow anonymous inserts for email opens" ON email_opens
  FOR INSERT 
  WITH CHECK (true);

DROP POLICY IF EXISTS "Allow anonymous inserts for email clicks" ON email_clicks;
CREATE POLICY "Allow anonymous inserts for email clicks" ON email_clicks
  FOR INSERT 
  WITH CHECK (true);

-- Allow admins to manage all tracking data
DROP POLICY IF EXISTS "Admins can manage email opens" ON email_opens;
DROP POLICY IF EXISTS "Admins can read email opens" ON email_opens;
CREATE POLICY "Admins can manage email opens" ON email_opens
  FOR ALL 
  USING (is_admin(auth.uid()));

DROP POLICY IF EXISTS "Admins can manage email clicks" ON email_clicks;
DROP POLICY IF EXISTS "Admins can read email clicks" ON email_clicks;
CREATE POLICY "Admins can manage email clicks" ON email_clicks
  FOR ALL 
  USING (is_admin(auth.uid()));

-- Note: Tracking routes use the service role key to bypass RLS entirely
-- This is necessary because:
-- 1. Tracking pixels need to work without authentication
-- 2. They need to update email_campaigns statistics (requires admin access)
-- 3. They need to check for existing records (SELECT)
-- The anonymous insert policies are a fallback, but the service role key is the primary method
-- All reads are restricted to admins only to protect tracking data

-- =============================================
-- Storage Bucket Policies for email-assets
-- =============================================
-- Note: Supabase storage uses bucket-level policies, not RLS
-- This migration assumes the email-assets bucket already exists
-- Bucket creation should be done manually via Supabase dashboard or CLI

-- Create storage policies for email-assets bucket
-- Admins can upload, update, and delete files
CREATE POLICY "Admins can upload to email-assets" ON storage.objects
  FOR INSERT
  WITH CHECK (
    bucket_id = 'email-assets' AND
    is_admin(auth.uid())
  );

CREATE POLICY "Admins can update email-assets" ON storage.objects
  FOR UPDATE
  USING (
    bucket_id = 'email-assets' AND
    is_admin(auth.uid())
  )
  WITH CHECK (
    bucket_id = 'email-assets' AND
    is_admin(auth.uid())
  );

CREATE POLICY "Admins can delete from email-assets" ON storage.objects
  FOR DELETE
  USING (
    bucket_id = 'email-assets' AND
    is_admin(auth.uid())
  );

-- Public read access for email-assets (needed for email clients to display images)
CREATE POLICY "Public can read email-assets" ON storage.objects
